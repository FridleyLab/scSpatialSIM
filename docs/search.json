[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 mIFsim authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"/articles/a01_Introduction.html","id":"spatial-point-patterns","dir":"Articles","previous_headings":"Background","what":"Spatial Point Patterns","title":"Introduction","text":"Spatial point patterns realization spatial point process models. points represent feature, case cells ecological studies can trees plants, space. space 2-dimensional x y axis arbitrary units. point spatial point pattern can marks - characteristics describe information point. marks can things like whether ’s positive negative specific phenotype tissue, perhaps size cell, even intensity fluorophore cells surface. spatial point pattern can provide us great deal information pathology looking cell spatial contexture. order understand cell contexture pathology, researchers can employ different spatial statistic methods describe feature spatial point pattern. simple descriptive statistic spatial point pattern lambda describes intensity. large lambda means large number points given boundary, small lambda means boundary area less points. Another summary statistic Ripley’s K(r) describes many points interest within r anchor cell. measurement can compared different things like complete spatial randomness (CSR) measurement estimate far observed cell contexture deviates random cell locations sample. addition Ripley’s K(r), several methods nearest neighbor G(r) function interaction variable developed Steinhart et. al.","code":""},{"path":"/articles/a01_Introduction.html","id":"simulating","dir":"Articles","previous_headings":"Background","what":"Simulating","title":"Introduction","text":"order compare metrics describing point patterns, developed simulation package: scSpatialSIM. main basis package using Gaussian kernels assign different characteristics underlying spatial point pattern. Gaussian kernel described 3 different ways package: kernel’s center, standard deviation x-direction standard deviation y-direction. k kernel means centers point pattern descriptors. kernels spatial point pattern described locations points, kernels can used give probability points - closer center k greater probability kernel describing farther away k center lower probability. probabilities range 0 1 assumes kernel centers ‘hot’ tissue/cell phenotype/hole, reality always case. Due inherent noise see tissues cell level, provided ability limit kernel center probability increase background probability. addition making simulations realistic, also allows abundance control cell phenotypes (lower max probability lower abundance).","code":""},{"path":"/articles/a01_Introduction.html","id":"using-scspatialsim","dir":"Articles","previous_headings":"","what":"Using scSpatialSIM","title":"Introduction","text":"process simulating cell type data streamlined similar way one thinks thinking real data. First, S4 SpatSimObj object initialized slots needed proceed whole simulation process. Slots inside kernels describe tissue, holes, cell phenotypes, simulation window, tabular format . SpatialSimulationObject() ready, point patterns can simulated (point patterns act ‘master’ next parts). point pattern similar extracellular matrix just places cells go identity cells. Thinking broadly, need create tissue regions images designated either tissue 1 tissue 2 (can interpreted tumor stroma). Separately, cell phenotypes can assigned cell. done separate kernels step allows high customization fine tuning simulated samples spatial contexture. parameters changed initialized values, stored object future can referred . Spatial statistics usually interested amount clustering points single mark type . example, shown high abundance low clustering cytotoxic T cells associated better overall survival missing cytotoxic T cells high grade serous ovarian cancer tumors. also instances colocalization 2 difference cell types might interest T cell B cells tumors. scSpatialSIM, provide methods perform spatial point patterns. Input parameters dictate layout first cell type. case one cell type wanted, shift value taken uses kernel first cell type (shift = 0) strong colocalization moved first cell types’ kernel towards Dirichlet vertices (shift = 1) segregation.","code":""},{"path":"/articles/a01_Introduction.html","id":"univariate-simulation","dir":"Articles","previous_headings":"Using scSpatialSIM","what":"Univariate Simulation","title":"Introduction","text":"order get started simulating cell type samples, need import package. create simulation object, can call CreateSimulationObject(), takes 3 arguments initialize object downstream functions: window - spatstat owin object boundary simulate points. window acts mask functions know simulate points later . sims - integer value number samples wanting simulated cell_types - number different phenotypes simulate, going single cell type window isn’t specified built 10x10 unit window used. make custom window, use spatstat.geom::owin Let’s create simulation object. simulation object attributes gradually filled progress. Using summary() method, can see simulation object inside need next. , 9 simulations default window wanting perform single cell type. method really useful fine tuning parameters get desired output shows exactly already done loading base object RDS file. Now simulation object parameters set within, need create point pattern. GenerateSpatialPattern() function takes spatial simulation object lambda, intensity point pattern. NOTE: large windows large lambdas, size spatial simulation object can grow fast mindful. parameters passed spatstat.random::rpoispp can passed GenerateSpatialPattern() end. , can check filling slots summary() even see new process looks like plot().  Next generate regions different tissue. purpose , tissue 1 tumor tissue 2 stroma. parameters initialized building spatial simulation tells downstream functions simulate things Gaussian kernel - GenerateTissue() one . nothing supplied function calling, default values. Alternatively, can specify function call. include regions within window like tissue regions simulated, number regions, standard deviation range probability falls around region centers, etc. Something whether ending kernel converted heatmap resolution. NOTE: smaller step_size used heatmap longer takes run mindful. simulating tissues can look summary spatial simulation object see newly filled slot. tissue kernel slot now filled number kernels matching number spatial processes . Let’s take look simulated tissue kernels PlotSimulation(). using negative ranges window, function use overlap default GenerateTissue() range window. See documentation GenerateTissue() details.  kernels randomly laid simulation region random sizes within constraints parameters provided. number tissue regions simulated fixed input k value, sampled distribution centered k. larger sdmin sdmax increase sizes tissue regions. See GenerateTissue() information. Generating holes can help assess need correcting metrics derived spatial statistics. example, pond center field, crops able planted yet measuring amount field just outside border say lots crops able fit. Sometimes, things need adjusted tissue sections stained second folds tears, leaving large area longer cells present. Even using holes assessing metrics, performing just create new column spatial files can later ignored. holes needed , can skipped. parameters go GenerateHoles() similar GenerateTissue() one addition: hole_prob proportion range point patterns become holes. parameters defaults set spatial simulation object created, can overridden particular area process wanted holes rest. number holes random long sum area within proportions . Let’s see kernels holes look. center holes highest probability removed Bernoulli distribution ‘hole’ ‘hole’.   Next thing us simulate positivity cells phenotype using GenerateCellPositivity(). Just like holes tissue, boundaries simulated positive cells fall stored parameters. helpful going back seeing done. However , 2 different parameters help set abundance (probs) , case multiple cell types, related cell types (shift). probs parameter used scale probabilities cell type first number away kernel peaks second maximum probability cell. higher abundance, maximum probability can set higher even increase minimum probability. issue point patterns multiple cell types entirely informed one another assigning cell types. B cells T cells distinct phenotypes therefore one cell shouldn’t positive . , use probability Bernoulli distribution ’s chance single cell positive 2 cell types, even max probability 0.1. univariate clustering, smaller standard deviations higher probability range increase amount clustering. Large standard deviations low probabilities make clustering metrics low. univariate cell simulation, shift metric nothing. similarity 2 cell types controlled shift value. shift = 0 use kernel used probabilities Cell Type 1 cell types, shift = 1 move Cell Type 1 kernel cells segregated (noise) Dirichlet vertices 3 kernel centers used. plot simulation object now specifying want see whole core, can see cells. little pockets positive cells also noise.","code":"library(scSpatialSIM) #> scSpatialSIM Version: #> 0.1.3.5 #>             _____             _   _       _  _____ _____ __  __ #>            / ____|           | | (_)     | |/ ____|_   _|  \\/  | #>   ___  ___| (___  _ __   __ _| |_ _  __ _| | (___   | | | \\  / | #>  / __|/ __|\\___ \\| '_ \\ / _` | __| |/ _` | |\\___ \\  | | | |\\/| | #>  \\__ \\ (__ ____) | |_) | (_| | |_| | (_| | |____) |_| |_| |  | | #>  |___/\\___|_____/| .__/ \\__,_|\\__|_|\\__,_|_|_____/|_____|_|  |_| #>                  | | #>                  |_| #>  #>  Fridley Lab Enjoy set.seed(333) #reproducibility custom_window = spatstat.geom::owin(xrange = c(0, 10), yrange = c(0, 10)) sim_object = CreateSimulationObject(sims = 9, cell_types = 1, window = custom_window) summary(sim_object) #> Spatial Simulation object for 9 simulated images. Currently, there are: #>  Window: x (0,10); y (0,10) #>  0 spatial point patterns #>  0 tissue kernels #>  0 hole kernels #>  0 cell kernels for 1 cell types sim_object = GenerateSpatialPattern(sim_object) summary(sim_object) #> Spatial Simulation object for 9 simulated images. Currently, there are: #>  Window: x (0,10); y (0,10) #>  9 spatial point patterns #>  0 tissue kernels #>  0 hole kernels #>  0 cell kernels for 1 cell types plot(sim_object, what = \"Patterns\", ncol = 1, nrow = 1, which = 1)#print only first point pattern sim_object = GenerateTissue(sim_object, density_heatmap = T, step_size = 0.1, cores = 1) #> Computing density heatmap #> Computing tissue probability summary(sim_object) #> Spatial Simulation object for 9 simulated images. Currently, there are: #>  Window: x (0,10); y (0,10) #>  9 spatial point patterns #>  9 tissue kernels #>  0 hole kernels #>  0 cell kernels for 1 cell types PlotSimulation(sim_object, which = 1:4, ncol = 2, nrow = 2, what = \"tissue heatmap\") sim_object = GenerateHoles(sim_object, density_heatmap = T, step_size = 0.1, cores = 1) #> Computing density heatmap #> Computing hole probability summary(sim_object) #> Spatial Simulation object for 9 simulated images. Currently, there are: #>  Window: x (0,10); y (0,10) #>  9 spatial point patterns #>  9 tissue kernels #>  9 hole kernels #>  0 cell kernels for 1 cell types PlotSimulation(sim_object, which = 1:8, ncol = 2, nrow = 2, what = \"hole heatmap\") #> $`1` #>  #> $`2` #>  #> attr(,\"class\") #> [1] \"list\"      \"ggarrange\" sim_object = GenerateCellPositivity(sim_object, k = 4,                                     sdmin = 3, sdmax = 5,                                     density_heatmap = T, step_size = 0.1, cores = 1, probs = c(0.0, 0.1),                                     shift = 1) #> Computing density heatmap for Cell 1 #> Computing probability for Cell 1 summary(sim_object) #> Spatial Simulation object for 9 simulated images. Currently, there are: #>  Window: x (0,10); y (0,10) #>  9 spatial point patterns #>  9 tissue kernels #>  9 hole kernels #>  9 cell kernels for 1 cell types PlotSimulation(sim_object, which = 1, what = \"whole core\")"},{"path":"/articles/a01_Introduction.html","id":"bivariate-simulation","dir":"Articles","previous_headings":"Using scSpatialSIM","what":"Bivariate Simulation","title":"Introduction","text":"process 2 cell types essentially single cell type addition shift value simulating cell types. Lets create another SpatSimObj get phenotype simulating step GenerateCellPositivity(). great feature scSpatialSIM works nicely magrittr pipe function immediately pass output one function next. previously mentioned, can specify shift values 0 use kernel cell types assign way identifiable colocalized Cell Type 1 Cell Type 2. First, low shift:  can see locations Cell Type 1 , Cell Type 2 also present. couple cells assigned positive Cell Type 1 Cell Type 2 taken consideration next steps. looking colocalization mutually exclusive cell types, removed. compare strong segregation Cell Type 1 Cell Type 2?  Tissue 2 ’s easier see regions Cell Type 1 regions Cell Type 2.","code":"#set seed set.seed(333) #create the new object bivariate_sim = CreateSimulationObject(sims = 5, cell_types = 2) %>%   #produce the point pattern   GenerateSpatialPattern() %>%   #make tissues   GenerateTissue(density_heatmap = T, step_size = 0.1, cores = 1) #> No `window` specified - defaulting to x (0, 10); y (0, 10) #> Computing density heatmap #> Computing tissue probability bivariate_sim_tmp  = GenerateCellPositivity(bivariate_sim, k = 4,                                     sdmin = 3, sdmax = 5,                                     density_heatmap = T, step_size = 0.1, cores = 1, probs = c(0.0, 0.1),                                     shift = 0) #> Computing density heatmap for Cell 1 #> Computing probability for Cell 1 #> Copying density heatmap for Cell 2 #> Computing probability for Cell 2  PlotSimulation(bivariate_sim_tmp, which = 1, what = \"whole core\") bivariate_sim_tmp  = GenerateCellPositivity(bivariate_sim, k = 4,                                     sdmin = 3, sdmax = 5,                                     density_heatmap = T, step_size = 0.1, cores = 1, probs = c(0.0, 0.1),                                     shift = 1) #> Computing density heatmap for Cell 1 #> Computing probability for Cell 1 #> Computing density heatmap for Cell 2 #> Computing probability for Cell 2  PlotSimulation(bivariate_sim_tmp, which = 1, what = \"whole core\")"},{"path":"/articles/a01_Introduction.html","id":"exporting-data","dir":"Articles","previous_headings":"","what":"Exporting Data","title":"Introduction","text":"Lastly, data likely wanted tabular format. Since multiple simulated point patterns, function CreateSpatialList() returns list data frames containing cell x y locations, tissue cell belongs , whether cell falls hole, positivity different cell types. Alternatively, ability CreateSpatialList() export spatial pattern data single data frame using single_df set TRUE. adds Image Name column keeps spatial pattern data separate, can split back list later use SummariseSpatial(), creates core level counts different cell types. spatial list summary table can now used packages like spatialTIME compute spatial statistics simulated data frames.","code":"spatial_list = CreateSpatialList(sim_object = bivariate_sim_tmp) head(spatial_list[[1]]) #>           x        y Tissue Assignment Cell 1 Assignment Cell 2 Assignment #> 1 5.7130558 1.274980          Tissue 2                 0                 0 #> 2 0.2011937 2.748664          Tissue 2                 0                 0 #> 3 7.2355739 6.800332          Tissue 2                 0                 0 #> 4 6.0939363 6.601037          Tissue 2                 0                 1 #> 5 3.0671935 2.480361          Tissue 2                 0                 0 #> 6 0.6350984 1.242892          Tissue 1                 0                 0 single_dataframe = CreateSpatialList(sim_object = bivariate_sim_tmp, single_df = TRUE) head(single_dataframe) #>       Image Name         x        y Tissue Assignment Cell 1 Assignment #> 1 Spatial Data 1 5.7130558 1.274980          Tissue 2                 0 #> 2 Spatial Data 1 0.2011937 2.748664          Tissue 2                 0 #> 3 Spatial Data 1 7.2355739 6.800332          Tissue 2                 0 #> 4 Spatial Data 1 6.0939363 6.601037          Tissue 2                 0 #> 5 Spatial Data 1 3.0671935 2.480361          Tissue 2                 0 #> 6 Spatial Data 1 0.6350984 1.242892          Tissue 1                 0 #>   Cell 2 Assignment #> 1                 0 #> 2                 0 #> 3                 0 #> 4                 1 #> 5                 0 #> 6                 0 summary_data = SummariseSpatial(spatial_list = spatial_list, markers = c(\"Cell 1 Assignment\", \"Cell 2 Assignment\")) head(summary_data) #> # A tibble: 5 × 6 #>   `Sample Tag`   `Total Cells` `Cell 1 Assignment` `Cell 2 Assignment` #>   <chr>                  <int>               <dbl>               <dbl> #> 1 Spatial Data 1          2495                 128                 104 #> 2 Spatial Data 2          2450                 119                 113 #> 3 Spatial Data 3          2500                 143                 124 #> 4 Spatial Data 4          2514                 111                  91 #> 5 Spatial Data 5          2486                 117                 100 #> # ℹ 2 more variables: `% Cell 1 Assignment` <dbl>, `% Cell 2 Assignment` <dbl>"},{"path":"/articles/a02_Using_with_spatialTIME.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Using with spatialTIME","text":"likely, going want use another package analyze simulated data produced scSpatialSIM. , show output scSpatialSIM works seemlessly spatial analysis package, spatialTIME","code":""},{"path":"/articles/a02_Using_with_spatialTIME.html","id":"simulating-data","dir":"Articles","previous_headings":"Background","what":"Simulating Data","title":"Using with spatialTIME","text":"First thing need simulate data. vignette(\"Introduction\") showed us can univariate way single cells positivity simulated bivaraiate way get positivity multiple cell types. can use data spatialTIME derive spatial statistics like Ripley’s K. See spatialTIME package information everything package can . vignette, stick single cell type look univariate clustering without holes display caution taken using observed Ripley’s K values. simulation object filled single cell type, can split spatial list well summary using CreateSpatialList() SummariseSpatial().","code":"library(scSpatialSIM) #> scSpatialSIM Version: #> 0.1.3.5 #>             _____             _   _       _  _____ _____ __  __ #>            / ____|           | | (_)     | |/ ____|_   _|  \\/  | #>   ___  ___| (___  _ __   __ _| |_ _  __ _| | (___   | | | \\  / | #>  / __|/ __|\\___ \\| '_ \\ / _` | __| |/ _` | |\\___ \\  | | | |\\/| | #>  \\__ \\ (__ ____) | |_) | (_| | |_| | (_| | |____) |_| |_| |  | | #>  |___/\\___|_____/| .__/ \\__,_|\\__|_|\\__,_|_|_____/|_____|_|  |_| #>                  | | #>                  |_| #>  #>  Fridley Lab Enjoy #set seed set.seed(333) #create the new object sim_object = CreateSimulationObject(sims = 5, cell_types = 1) %>%     #produce the point pattern     GenerateSpatialPattern() #> No `window` specified - defaulting to x (0, 10); y (0, 10)     #make tissues sim_object = GenerateTissue(sim_object, density_heatmap = F) %>%     #create holes     GenerateHoles(hole_prob = c(0.3, 0.5), density_heatmap = F) %>%     #Create positive/negative cells     GenerateCellPositivity(probs = c(0, 0.9)) #> Computing tissue probability #> Computing hole probability #> Computing probability for Cell 1 #creating the spatial list spatial_list = CreateSpatialList(sim_object, single_df = F) #summarise the spatial list summary_df = SummariseSpatial(spatial_list, markers = \"Cell 1 Assignment\") head(summary_df) #> # A tibble: 5 × 4 #>   `Sample Tag`   `Total Cells` `Cell 1 Assignment` `% Cell 1 Assignment` #>   <chr>                  <int>               <dbl>                 <dbl> #> 1 Spatial Data 1          2495                 673                  27.0 #> 2 Spatial Data 2          2450                 475                  19.4 #> 3 Spatial Data 3          2500                 582                  23.3 #> 4 Spatial Data 4          2514                 525                  20.9 #> 5 Spatial Data 5          2486                 450                  18.1"},{"path":"/articles/a02_Using_with_spatialTIME.html","id":"using-with-spatialtime","dir":"Articles","previous_headings":"Background","what":"Using with spatialTIME","title":"Using with spatialTIME","text":"spatialTIME package requires input 3 things. 1) spatial data frames list format, 2) summary spatial data frames, 3) clinical data frames summary data frame acts linker spatial data frame IDs entries clinical data frame. spatial data frames need 1 column: name. pretty easy . summary data frame already contains names spatial data frames needs patient ID added. number 3 data needed clinical data frame. sake example just make single columned data frame 1 5 match “Patient ID” summary data. column names used creating mIF object along 3 data objects. Since window 0 10 (10 units), keep search radius max less 5. Lets Univariate Ripley’s K 0 3 units visualize results.  now, using simulated cells. can filter spatial_list create another mIF object doesn’t cells belonging class “hole” (Hole Assignment == “Keep”). now, sub-setting Tissue 1 Tissue 2 left alone. Let’s create mIF run Ripley’s K . see importance using exact CSR approach (permutation) holes samples, first look spatial plots see much holes impacting distribution points.  regions holes rather small wouldn’t  clearly shows exact typically larger values theoretical (positive values). can visualized calculating frequency rs exact CSR measurement greater theoretical CSR estimate, indicating theoretical underestimating CSR cores.","code":"library(spatialTIME) #> spatialTIME version: #> 1.3.4.5 #> If using for publication, please cite our manuscript: #> https://doi.org/10.1093/bioinformatics/btab757 #loop over all spatial data frames and add their names sf_names = names(spatial_list) spatial_list = lapply(setNames(sf_names, sf_names), function(nam){   spatial_list[[nam]] %>%     dplyr::mutate(`Sample Tag` = nam, .before = 1) }) summary_df$`Patient ID` = 1:5 clinical = data.frame(`Patient ID` = 1:5, check.names = F) mif = create_mif(clinical_data = clinical,                  sample_data = summary_df,                  spatial_list = spatial_list,                  patient_id = \"Patient ID\",                  sample_id = \"Sample Tag\") mif #> 5 patients spanning 5 samples and 5 spatial data frames were found mif = ripleys_k(mif = mif, mnames = \"Cell 1 Assignment\", r_range = seq(0, 3, 0.1),                  permute = FALSE, edge_correction = \"translation\", workers = 1,                 xloc = \"x\", yloc = \"y\") #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` library(ggplot2) mif$derived$univariate_Count %>%   ggplot() +   geom_line(aes(x = r, y = `Degree of Clustering Exact`, color = `Sample Tag`)) +   labs(title = \"Univariate Clustering - Simulation\") mif_holes = create_mif(clinical_data = clinical,                  sample_data = summary_df,                  spatial_list = lapply(spatial_list, function(spat){                    spat %>%                      dplyr::filter(`Hole Assignment` == \"Keep\")                  }),                  patient_id = \"Patient ID\",                  sample_id = \"Sample Tag\") mif_holes = ripleys_k(mif = mif_holes, mnames = \"Cell 1 Assignment\", r_range = seq(0, 3, 0.1),                  permute = FALSE, edge_correction = \"translation\", workers = 1,                 xloc = \"x\", yloc = \"y\") #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` #> Joining with `by = join_by(r)` mif_holes$spatial %>%   do.call(dplyr::bind_rows, .) %>%   ggplot() +   geom_point(aes(x = x, y = y, color = as.factor(`Cell 1 Assignment`))) +   facet_wrap(~`Sample Tag`) dat = do.call(dplyr::bind_rows, mif_holes$derived$univariate_Count) dat %>%   dplyr::mutate(`Exact-Theo` = `Exact CSR` - `Theoretical CSR`) %>%   ggplot() +   geom_density(aes(x = `Exact-Theo`, fill = `Sample Tag`), alpha = 0.2, adjust = 0.2) dat %>%     dplyr::mutate(`Exact-Theo` = `Exact CSR` - `Theoretical CSR`) %>%     dplyr::group_by(`Sample Tag`) %>%     dplyr::mutate(prop = ifelse(`Exact-Theo` > 0, 1/dplyr::n(), 0)) %>%     dplyr::select(`Sample Tag`, r, `Exact-Theo`, prop) %>%     dplyr::summarise(`Total Fraction` = sum(prop)) #> # A tibble: 5 × 2 #>   `Sample Tag`   `Total Fraction` #>   <chr>                     <dbl> #> 1 Spatial Data 1            0.355 #> 2 Spatial Data 2            0.645 #> 3 Spatial Data 3            0.968 #> 4 Spatial Data 4            0.968 #> 5 Spatial Data 5            0.968"},{"path":"/articles/a03_CellAttributes.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Adding Cell Attributes","text":"Spatial data use can shown previous vignettes, points cells either positive negative particular feature. Often single-cell spatial data might cell types (T cell, B cell, malignant cell, etc) compartment cell originated (lymph node, tumor, stroma, etc). However, make measurements, continuous (pixel intensity, protein abundance, gene expression, etc) get collapsed class. continuous measures still important provide granular understanding data. vignette, demonstrate usecase scSpatialSIM simulate continuous data apply autocorrelation method, Moran’s spdep package.","code":""},{"path":"/articles/a03_CellAttributes.html","id":"simulating-data","dir":"Articles","previous_headings":"Background","what":"Simulating Data","title":"Adding Cell Attributes","text":"demonstrate simulation protein (CD3) expressed cells TMA. way scSpatialSIM first simulating samples cell types, marked point pattern, using positive/negative assignment cells simulate multimodal distribution values. vignette CD3 protein expression, means simulating points positive negative, simulating high (positive) low (negative) CD3 expression. procedure similar process can performed seen vignette(\"Using SpatialTIME) creating simulation object single cell type. , create 2 simulation objects different cell clustering levels compare autocorrelation values different samples. simulation object, stick single cell type. using GenerateCellPositivity(), need scale probs parameter null case due cells probability positive results much greater abundances positive cells. Good quality control always look data. simulation study, thousands samples simulated resulting better distribution estimates abundance T cells clustered null scenarios. simulation objects 5 simulated samples distributions rough. Even , visualizing abundance give us general idea.  5 samples null/negative control clustered scenarios, pretty similar average, maybe slightly higher T cell abundance clustered samples. running larger study, tuning abundance similar important. recommendation running clustered scenarios abundance cluster size satisfactory (changing sdmin, sdmax, probs), setting high probs no_kernel = TRUE scenario mean/median clustered abundance. Due implementation no_kernel = TRUE, cell abundance sample scenario similar (little variation). variability desired, abundance can assigned outside scSpatialSIM using rnorm mean standard deviation cell abundance clustering scenarios, applying null scenario sample lapply rbinom slightly adjust prob . scenarios T cells simulated, can extract samples simulation objects using CreateSpatialList(). creates either list data.frame depending single_df - keep FALSE. want T cells simulation scenarios CD3 protein distribution combine single list, give list elements appropriate names. use GenerateDistributions() produce protein abundance. demonstration purposes, use arbitrary values positive negative protein abundances. can also derived real world data multiplex immunofluorescence protein spatial transcriptomics gene expression.","code":"library(scSpatialSIM) #> scSpatialSIM Version: #> 0.1.3.5 #>             _____             _   _       _  _____ _____ __  __ #>            / ____|           | | (_)     | |/ ____|_   _|  \\/  | #>   ___  ___| (___  _ __   __ _| |_ _  __ _| | (___   | | | \\  / | #>  / __|/ __|\\___ \\| '_ \\ / _` | __| |/ _` | |\\___ \\  | | | |\\/| | #>  \\__ \\ (__ ____) | |_) | (_| | |_| | (_| | |____) |_| |_| |  | | #>  |___/\\___|_____/| .__/ \\__,_|\\__|_|\\__,_|_|_____/|_____|_|  |_| #>                  | | #>                  |_| #>  #>  Fridley Lab Enjoy set.seed(333) #create simulation object for tight clusters sim_object_tight = CreateSimulationObject(sims = 5, cell_types = 1) %>%   #simulate point pattern   GenerateSpatialPattern() #> No `window` specified - defaulting to x (0, 10); y (0, 10) #create simulation object for no clusters sim_object_null = CreateSimulationObject(sims = 5, cell_types = 1) %>%   #simulate point pattern   GenerateSpatialPattern() #> No `window` specified - defaulting to x (0, 10); y (0, 10) sim_object_tight = GenerateCellPositivity(sim_object_tight,                                            k = 4,                                           sdmin = 1, sdmax = 3,                                           density_heatmap = F,                                           probs = c(0.0, 0.9)) #> Computing probability for Cell 1  sim_object_null = GenerateCellPositivity(sim_object_null,                                            probs = c(0.0, 0.2),                                           no_kernel = TRUE) #> random cell assignments without kernels #> Computing probability for Cell 1 library(ggplot2) #calculate abundance for clustered samples cluster_abundance = sapply(sim_object_tight@`Spatial Files`, function(x){   sum(x$`Cell 1 Assignment` == \"Positive\")/nrow(x) }) #calculate abundance for null/negative control samples null_abundance = sapply(sim_object_null@`Spatial Files`, function(x){   sum(x$`Cell 1 Assignment` == \"Positive\")/nrow(x) }) #create histogram of abundances data.frame(abundance = c(cluster_abundance, null_abundance),            simulation = c(rep(\"clustered\", 5), rep(\"null\", 5))) %>%   ggplot() +    geom_histogram(aes(x = abundance, fill = simulation)) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. #extract simulated samples to make lists cluster_list = CreateSpatialList(sim_object_tight, single_df = FALSE) null_list = CreateSpatialList(sim_object_null, single_df = FALSE) #combine lists to make a single list spatial_list = c(cluster_list, null_list) names(spatial_list) = c(paste0(\"Clustered Sample \", 1:5),                         paste0(\"Null Sample \", 1:5)) spat_data_distribution = GenerateDistributions(spatial_list,                                                 positive_mean = 15,                                                negative_mean = 5,                                                positive_sd = 3,                                                negative_sd = 1)"},{"path":"/articles/a03_CellAttributes.html","id":"spatial-autocorrelation-with-morans-i","dir":"Articles","previous_headings":"","what":"Spatial Autocorrelation with Moran’s I","title":"Adding Cell Attributes","text":"Spatial autocorrelation measure similar common Pearson correlation extended look spatial relationships. like think Moran’s similar value (case expression protein) anchor cell aggregated value ’s neighbors. similar CD3 expression cells CD3 expression surrounding cells? Similar Pearson correlation, row-standardized weight calculation Moran’s range -1 1, greater positive values indicate strong similarity value cells/points neighboring cells/points values, negative indicates strong dissimilarity value neighboring cells values, 0 indicates spatial relationship. assess Moran’s simulated samples, use spdep package. couple steps get using spdep::moran.test() function like calculating neighbors creating weight list. number neighbors used can also influence results Moran’s , beyond scope tutorial. , use cells 10 nearest neighbors assess autocorrelation. Row-standardized weight means weights neighbors sum 1. expect CD3 expression show greater spatial autocorrelation samples cells simulated clustered samples null clustering cases. results data frame format thanks dplyrs bind_rows() function allow us visualize Moran’s autocorrelation. can use ggplot plot simple boxplots show distribution calculated Moran’s . null cases, expect values around 0 indicate spatial relationship simulated protein expression.","code":"#identify neighbors #create weight list #calculate moran's i library(dplyr) library(spdep) #> Loading required package: spData #> To access larger datasets in this package, install the spDataLarge #> package with: `install.packages('spDataLarge', #> repos='https://nowosad.github.io/drat/', type='source')` #> Loading required package: sf #> Linking to GEOS 3.13.0, GDAL 3.8.5, PROJ 9.5.1; sf_use_s2() is TRUE results = lapply(spat_data_distribution, function(dat){   #convert data frame to an sf object compatable with other spdep functions   sf_dat = st_as_sf(dat, coords = c(\"x\", \"y\"))   #calculate the 10 nearest neighbors   knn = knearneigh(sf_dat, k = 10)   #convert knn to neighbor list   knn_nb = knn2nb(knn)   #convert neighbor list to weight list   knn_nb_listw = nb2listw(knn_nb,                           style = \"W\")   #calculate moran's I on the simulated protein expression \"Cell 1 Var\"   res = moran.test(sf_dat$`Cell 1 Var`,                    listw = knn_nb_listw)   #convert results to a data frame   data.frame(as.list(res$estimate), check.names = FALSE) }) %>%   #convert list results to a data frame   bind_rows(.id = \"Sample ID\") #look at the results head(results) #>            Sample ID Moran I statistic   Expectation     Variance #> 1 Clustered Sample 1         0.3758399 -0.0004009623 7.410341e-05 #> 2 Clustered Sample 2         0.3402620 -0.0004083299 7.533573e-05 #> 3 Clustered Sample 3         0.3052300 -0.0004001601 7.395509e-05 #> 4 Clustered Sample 4         0.3792493 -0.0003979308 7.338008e-05 #> 5 Clustered Sample 5         0.2748225 -0.0004024145 7.445675e-05 #> 6      Null Sample 1        -0.0101181 -0.0003974563 7.353824e-05 results2 = results %>%     mutate(Group = rep(c(\"Clustered\", \"Null\"), each = 5)) results2 %>%   ggplot() +   geom_boxplot(aes(x = Group, y = `Moran I statistic`)) +   theme_classic()"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alex Soupir. Author. Christopher Wilson. Author. Jordan Creed. Author. Julia Wrobel. Author. Oscar Ospina. Author. Brooke Fridley. Author, copyright holder. Fridley Lab. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Soupir , Wilson C, Creed J, Wrobel J, Ospina O, Fridley B (2025). scSpatialSIM: Point Pattern Simulator Spatial Cellular Data. R package version 0.1.3.5, https://github.com/FridleyLab/scSpatialSIM.","code":"@Manual{,   title = {scSpatialSIM: A Point Pattern Simulator for Spatial Cellular Data},   author = {Alex Soupir and Christopher Wilson and Jordan Creed and Julia Wrobel and Oscar Ospina and Brooke Fridley},   year = {2025},   note = {R package version 0.1.3.5},   url = {https://github.com/FridleyLab/scSpatialSIM}, }"},{"path":"/index.html","id":"scspatialsim","dir":"","previous_headings":"","what":"A Point Pattern Simulator for Spatial Cellular Data","title":"A Point Pattern Simulator for Spatial Cellular Data","text":"point pattern simulator R package spatial cellular data","code":""},{"path":"/index.html","id":"installing-scspatialsim-to-rstudio","dir":"","previous_headings":"","what":"Installing scSpatialSIM to RStudio","title":"A Point Pattern Simulator for Spatial Cellular Data","text":"install scSpatialSIM, required devtools remotes installed install_github() function:","code":"if (!require(\"devtools\", quietly = TRUE))   install.packages(\"devtools\")  devtools::install_github(\"FridleyLab/mIFsim@v0.1.3.3\")"},{"path":"/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"A Point Pattern Simulator for Spatial Cellular Data","text":"interested documentation tutorials, please visit: https://fridleylab.github.io/scSpatialSIM/index.html","code":""},{"path":"/index.html","id":"github-repository","dir":"","previous_headings":"","what":"GitHub Repository","title":"A Point Pattern Simulator for Spatial Cellular Data","text":"source code, can click GitHub icon upper right corner pkgdown site follow link: https://github.com/FridleyLab/scSpatialSIM/","code":""},{"path":"/reference/CalculateDensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Simulation Heatmaps — CalculateDensity","title":"Compute Simulation Heatmaps — CalculateDensity","text":"Compute Simulation Heatmaps","code":""},{"path":"/reference/CalculateDensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Simulation Heatmaps — CalculateDensity","text":"","code":"CalculateDensity(   sim_object,   steps = NULL,   which = \"all\",   step_size = 1,   cores = 1 )"},{"path":"/reference/CalculateDensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Simulation Heatmaps — CalculateDensity","text":"sim_object object created CreateSimulationObject steps simulation steps compute heatmaps (Tissue, Holes, Cells, ) simulation compute step_size resolution heatmap cores number cpu cores","code":""},{"path":"/reference/CalculateDensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Simulation Heatmaps — CalculateDensity","text":"new SpatSimObj probability densities calculated","code":""},{"path":"/reference/CreateSimulationObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a spatial simulation object. — CreateSimulationObject","title":"Create a spatial simulation object. — CreateSimulationObject","text":"function creates SpatSimObj spatial simulations. object contains information simulation window, number simulations perform, lists cells, Tissue1/Tissue2, holes, spatial files.","code":""},{"path":"/reference/CreateSimulationObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a spatial simulation object. — CreateSimulationObject","text":"","code":"CreateSimulationObject(window = NULL, sims = NULL, cell_types = 1)"},{"path":"/reference/CreateSimulationObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a spatial simulation object. — CreateSimulationObject","text":"window object class owin representing simulation window. NULL, defaults rectangular window size (0,10) x y directions. sims number simulations perform. NULL l ess 1, defaults 3. cell_types number cell types. Defaults 1.","code":""},{"path":"/reference/CreateSimulationObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a spatial simulation object. — CreateSimulationObject","text":"SpatSimObj containing simulation window, number simulations perform, lists cells, Tissue1/Tissue2, holes, spatial files.","code":""},{"path":"/reference/CreateSimulationObject.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a spatial simulation object. — CreateSimulationObject","text":"simulation window represented object class owin, specifies extent shape spatial domain simulations performed. window provided, function creates rectangular window size (0,10) x y directions. sims argument specifies number simulations perform. set NULL less 1, function defaults 3. cell_types argument specifies number cell types include simulation. default, function creates single cell type, represented object class Cell. SpatSimObj composed following classes: Window object class owin. integer Sims specifying number simulations perform. list Cells class Cell. Tissue object class Tissue1/Tissue2, representing Tissue1/Tissue2 components simulation. Holes object class Holes, representing holes simulation. list Spatial Files containing spatial data associated simulation.","code":""},{"path":"/reference/CreateSimulationObject.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a spatial simulation object. — CreateSimulationObject","text":"","code":"CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10) #> Spatial Simulation object for 3 simulated images. Currently, there are: #> \tWindow: x (0,10); y (0,10) #> \t0 spatial point patterns #> \t0 tissue kernels #> \t0 hole kernels #> \t0 cell kernels for 1 cell types"},{"path":"/reference/CreateSpatialList.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Spatial Files from a SpatSimObj — CreateSpatialList","title":"Get Spatial Files from a SpatSimObj — CreateSpatialList","text":"function extracts 'Spatial Files' slot Spatial Simulation Object removes probability columns converting 'Positive' 'Negative' cell assignment columns 1 0, respectively.","code":""},{"path":"/reference/CreateSpatialList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Spatial Files from a SpatSimObj — CreateSpatialList","text":"","code":"CreateSpatialList(sim_object, single_df = FALSE, multihit_action = \"random\")"},{"path":"/reference/CreateSpatialList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Spatial Files from a SpatSimObj — CreateSpatialList","text":"sim_object SpatSimObj single_df boolean whether collapse output list data frames single data frame . default FALSE multihit_action string value 'random', 'drop', 'keep' cells positive multiple cell assignments","code":""},{"path":"/reference/CreateSpatialList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Spatial Files from a SpatSimObj — CreateSpatialList","text":"list data frames, one simulated cell type, cleaned columns","code":""},{"path":"/reference/CreateSpatialList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Spatial Files from a SpatSimObj — CreateSpatialList","text":"output function creates list spatial files formatted way allow direct import mIF object package 'spatialTIME'","code":""},{"path":"/reference/ExtractParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Simulation Parameters — ExtractParameters","title":"Get Simulation Parameters — ExtractParameters","text":"Get Simulation Parameters","code":""},{"path":"/reference/ExtractParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Simulation Parameters — ExtractParameters","text":"","code":"ExtractParameters(sim_object, steps = NULL)"},{"path":"/reference/ExtractParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Simulation Parameters — ExtractParameters","text":"sim_object simulation object created CreateSimulationObject steps parameters extract SpatSimObj","code":""},{"path":"/reference/ExtractParameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Simulation Parameters — ExtractParameters","text":"list S3 clas SimParams containing parameters stored sim_object","code":""},{"path":"/reference/ExtractParameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Simulation Parameters — ExtractParameters","text":"function return paramters stored simulation object. simulation steps run, return default parameters. defaults written new parameters provided step.","code":""},{"path":"/reference/ExtractParameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Simulation Parameters — ExtractParameters","text":"","code":"#create simulation object sim_obj = CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10) #extract default paramters for the Tissue simulation step defs = ExtractParameters(sim_obj, \"Tissue\") #> \tTissue has not yet been simulated"},{"path":"/reference/GenerateCellPositivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Cell Positivity — GenerateCellPositivity","title":"Generate Cell Positivity — GenerateCellPositivity","text":"Generate probability cell positive given set simulation parameters file SpatSimObj.","code":""},{"path":"/reference/GenerateCellPositivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Cell Positivity — GenerateCellPositivity","text":"","code":"GenerateCellPositivity(   sim_object,   k = NA,   xmin = NA,   xmax = NA,   ymin = NA,   ymax = NA,   sdmin = 1/2,   sdmax = 2,   probs = c(0, 1),   Force = FALSE,   density_heatmap = FALSE,   step_size = 1,   cores = 1,   shift = 0,   random = FALSE,   overwrite = FALSE,   use_window = FALSE,   no_kernel = FALSE )"},{"path":"/reference/GenerateCellPositivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Cell Positivity — GenerateCellPositivity","text":"sim_object SpatSimObj object containing simulated data. k integer specifying number clusters simulated patterns xmin numeric value specifying minimum x value kernel. xmax numeric value specifying maximum x value kernel. ymin numeric value specifying minimum y value kernel. ymax numeric value specifying maximum y value kernel. sdmin numeric value specifying minimum standard deviation kernel. sdmax numeric value specifying maximum standard deviation kernel. probs Either vector c(low probability, high probability) cell types data frame row low high probabilities cell type. data frame, number rows must equal number cells Force logical value indicating whether force simulation parameters within simulation window limits. density_heatmap logical value indicating whether compute density heatmap cell. step_size numeric value specifying step size grid points within window. cores integer value specifying number cores use parallel computation. shift value 0 1 related second cell type first random whether randomly generate kernels cells 2 , uf TRUE, shift used overwrite boolean whether overwrite existing cell kernels assignments present use_window boolean whether use simulation window set x y limits no_kernel boolean whether create kernels randomly assign points positive based probs","code":""},{"path":"/reference/GenerateCellPositivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Cell Positivity — GenerateCellPositivity","text":"Returns original scSpatialSIM object additional generated data added cell object.","code":""},{"path":"/reference/GenerateCellPositivity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Cell Positivity — GenerateCellPositivity","text":"function generates probability cell positive given set simulation parameters f file scSpatialSIM object. creates kernel parameter list k clusters simulated pattern computes probability point grid points within window cell. function also computes density heatmap cell density_heatmap set TRUE.","code":""},{"path":"/reference/GenerateDistributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Characteristic Distributions of Cells — GenerateDistributions","title":"Generate Characteristic Distributions of Cells — GenerateDistributions","text":"Generate Characteristic Distributions Cells","code":""},{"path":"/reference/GenerateDistributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Characteristic Distributions of Cells — GenerateDistributions","text":"","code":"GenerateDistributions(   spatial_data,   positive_mean = 10,   negative_mean = 2,   positive_sd = 2,   negative_sd = 1 )"},{"path":"/reference/GenerateDistributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Characteristic Distributions of Cells — GenerateDistributions","text":"spatial_data object either class list data.frame. Can created SpatSimObj CreateSpatialList positive_mean, negative_mean number mean center distribution positive negative cell types. Can single number vector length matching number Cells. positive_sd, negative_sd number standard deviation around positive cell type mean. Can single value length number Cells.","code":""},{"path":"/reference/GenerateDistributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Characteristic Distributions of Cells — GenerateDistributions","text":"object class input spatial_data new columns containing distributions positive/negative assigned cells","code":""},{"path":"/reference/GenerateDistributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Characteristic Distributions of Cells — GenerateDistributions","text":"","code":"#create simulation object spatial_data = CreateSimulationObject(sims = 1, cell_types = 1) %>%   #produce the point pattern   GenerateSpatialPattern() %>%   #make tissues   GenerateTissue(density_heatmap = FALSE, step_size = 0.1, cores = 1) %>%   #create positive and negative cells   GenerateCellPositivity(k = 4, sdmin = 3, sdmax = 5,   density_heatmap = FALSE, step_size = 1, cores = 1, probs = c(0.0, 0.1), shift = 0) %>%   #convert to a list of spatial data frames   CreateSpatialList(single_df = FALSE) #> No `window` specified - defaulting to x (0, 10); y (0, 10) #> Computing tissue probability #> Computing probability for Cell 1 spat_data_distribution = GenerateDistributions(spatial_data)"},{"path":"/reference/GenerateHoles.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate holes in a spatial simulation object — GenerateHoles","title":"Generate holes in a spatial simulation object — GenerateHoles","text":"function generates holes (regions low probability) spatial simulation object based user-defined parameters. function uses kernel density estimate simulate holes, returns modified version input object holes added. function also options compute density heatmap assign points within holes dropped kept based scaled probability value.","code":""},{"path":"/reference/GenerateHoles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate holes in a spatial simulation object — GenerateHoles","text":"","code":"GenerateHoles(   sim_object,   xmin = NA,   xmax = NA,   ymin = NA,   ymax = NA,   sdmin = 1/2,   sdmax = 2,   hole_prob = c(0.2, 0.35),   force = FALSE,   density_heatmap = FALSE,   step_size = 1,   cores = 1,   overwrite = FALSE,   use_window = FALSE )"},{"path":"/reference/GenerateHoles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate holes in a spatial simulation object — GenerateHoles","text":"sim_object spatial simulation object class SpatSimObj xmin Minimum x-coordinate holes (default: NA) xmax Maximum x-coordinate holes (default: NA) ymin Minimum y-coordinate holes (default: NA) ymax Maximum y-coordinate holes (default: NA) sdmin Minimum standard deviation kernels (default: 1/2) sdmax Maximum standard deviation kernels (default: 2) hole_prob vector length 2 minimum maximum probabilities point within hole (default: c(0.2, 0.35)) force Logical; TRUE, forces function simulate outside window boundaries (default: FALSE) density_heatmap Logical; TRUE, computes density heatmap (default: FALSE) step_size step size grid (default: 1) cores number cores use parallel processing (default: 1) overwrite boolean replace holes simulated previously use_window boolean whether use simulation window set x y limits","code":""},{"path":"/reference/GenerateHoles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate holes in a spatial simulation object — GenerateHoles","text":"modified spatial simulation object holes added","code":""},{"path":"/reference/GenerateHoles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate holes in a spatial simulation object — GenerateHoles","text":"function first checks input object correct class, parameters NULL. parameters NULL, function stops error message. x- y-ranges holes extend beyond boundaries simulation window, function also stops error message, unless force parameter set TRUE. function produces kernel parameter lists simulated pattern, generates grid based user-defined step size. density_heatmap set TRUE, function computes density heatmap using CalculateGrid function. Finally, function computes hole probabilities simulated pattern, assigns point dropped kept based scaled probability value, returns modified simulation object.","code":""},{"path":"/reference/GenerateHoles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate holes in a spatial simulation object — GenerateHoles","text":"","code":"sim_object <- CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10)  #simulate points sim_object <- GenerateSpatialPattern(sim_object, lambda = 20)  # Generate tissue with default parameters sim_object <- GenerateTissue(sim_object) #> Computing tissue probability  # Generate holes in the simulation object sim_object <- GenerateHoles(sim_object, hole_prob = c(0.1, 0.3), force = TRUE) #> Computing hole probability"},{"path":"/reference/GenerateSpatialPattern.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Spatial Point Pattern — GenerateSpatialPattern","title":"Generate Spatial Point Pattern — GenerateSpatialPattern","text":"Generate spatial point pattern within simulation object's window using Poisson point process.","code":""},{"path":"/reference/GenerateSpatialPattern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Spatial Point Pattern — GenerateSpatialPattern","text":"","code":"GenerateSpatialPattern(   sim_object,   lambda = 25,   ...,   overwrite = FALSE,   gridded = FALSE,   grid_shift = 0.5 )"},{"path":"/reference/GenerateSpatialPattern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Spatial Point Pattern — GenerateSpatialPattern","text":"sim_object 'SpatSimObj' containing window. lambda intensity point pattern Default 25. ... Additional arguments passed 'rpoispp'. overwrite boolean indicating whether replace point patterns exist object gridded boolean value whether simulate point pattern grid. See details . grid_shift amount move alternative columns gridded; -0.5 0.5","code":""},{"path":"/reference/GenerateSpatialPattern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Spatial Point Pattern — GenerateSpatialPattern","text":"updated 'sim_object' simulated point process added 'Processes' slot.","code":""},{"path":"/reference/GenerateSpatialPattern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Spatial Point Pattern — GenerateSpatialPattern","text":"function generates spatial point process within window 'sim_object' using Poisson point pattern intensity 'lambda'. simulated point pattern added 'Patterns' slot 'sim_object'. Additional arguments can passed 'rpoispp' function. gridded parameter used simulating point patterns represent som spatial transcriptomic technologies visium, rather like cell randomly distributed sample, spots data measured evenly spaced.","code":""},{"path":"/reference/GenerateSpatialPattern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Spatial Point Pattern — GenerateSpatialPattern","text":"","code":"sim_object <- CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10) sim_object <- GenerateSpatialPattern(sim_object, lambda = 30)"},{"path":"/reference/GenerateTissue.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Tissue — GenerateTissue","title":"Generate Tissue — GenerateTissue","text":"function generates simulated tissue using specified number clusters spatial parameters pattern simulation object. tissue represented grid points probabilities belonging tissue 1 tissue 2, based Gaussian kernel density estimate calculated pattern","code":""},{"path":"/reference/GenerateTissue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Tissue — GenerateTissue","text":"","code":"GenerateTissue(   sim_object,   k = NA,   xmin = NA,   xmax = NA,   ymin = NA,   ymax = NA,   sdmin = 1/2,   sdmax = 2,   force = FALSE,   density_heatmap = FALSE,   step_size = 1,   cores = 1,   overwrite = FALSE,   use_window = FALSE )"},{"path":"/reference/GenerateTissue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Tissue — GenerateTissue","text":"sim_object SpatSimObj created CreateSimulationObject. k Number clusters generate pattern xmin Minimum x-coordinate cluster centers. xmax Maximum x-coordinate cluster centers. ymin Minimum y-coordinate cluster centers. ymax Maximum y-coordinate cluster centers. sdmin Minimum standard deviation cluster kernels. sdmax Maximum standard deviation cluster kernels. force Logical, whether force generation tissue even generated cluster centers fall outside simulation window. FALSE, error thrown cluster centers outside window. density_heatmap Logical, whether calculate density heatmap simulated tissue. TRUE, grid points generated covering entire simulation window, probability grid point belonging tissue 1 calculated based generated tissue probability. step_size Grid step size density heatmap. cores Number cores use parallel processing density calculations. overwrite boolean whether overwrite tissue kernels already exist use_window boolean whether use simulation window set x y limits","code":""},{"path":"/reference/GenerateTissue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Tissue — GenerateTissue","text":"modified 'Spatial Simulation Object' updated tissue grids assigned tissue types simulated pattern.","code":""},{"path":"/reference/GenerateTissue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Tissue — GenerateTissue","text":"function generates simulated tissue pattern simulation object first generating k clusters within specified x y ranges standard deviation within specified range. , Gaussian kernel density estimate calculated pattern using generated clusters center points specified standard deviation kernel size. density estimates represent probability point simulation window belonging tissue 1 tissue 2. density_heatmap = TRUE, density heatmap calculated using grid points covering entire simulation window. Finally, simulated point, probability belonging tissue 1 calculated based kernel density estimate, tissue type assigned probability proportional probability belonging tissue 1.","code":""},{"path":"/reference/GenerateTissue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Tissue — GenerateTissue","text":"","code":"# Create a simulation object with a window and point pattern sim_object <- CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10)  #simulate points sim_object <- GenerateSpatialPattern(sim_object, lambda = 20)  # Generate tissue with default parameters sim_object <- GenerateTissue(sim_object) #> Computing tissue probability"},{"path":"/reference/PlotSimulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Simulation — PlotSimulation","title":"Plot Simulation — PlotSimulation","text":"Plot different aspects SpatSimObj","code":""},{"path":"/reference/PlotSimulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Simulation — PlotSimulation","text":"","code":"PlotSimulation(   sim_object,   nrow = 1,   ncol = 1,   which = 1,   what = \"tissue heatmap\" )"},{"path":"/reference/PlotSimulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Simulation — PlotSimulation","text":"sim_object SpatSimObj nrow Number rows plots (applicable one plot made) ncol Number columns plots (applicable one plot made) Index elements SpatSimObj plotted plot (\"tissue heatmap\", \"hole heatmap\", \"whole core\")","code":""},{"path":"/reference/PlotSimulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Simulation — PlotSimulation","text":"plot grid plots, depending input arguments","code":""},{"path":"/reference/PlotSimulation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Simulation — PlotSimulation","text":"PlotSimulation function used plot different aspects SpatSimObj function takes sim_object first argument, object class \"Spatial Simulation Object\". function can used plot different aspects simulation, heatmaps tissue holes, plot whole core assigned cells colored type. set \"tissue heatmap\" \"hole heatmap\", function plot heatmaps specified tissue hole. set \"whole core\", function plot entire core assigned cells colored type. single element sim_object can plotted set \"whole core\". equal \"tissue points\", \"hole points\", \"tissue hole points\" result point plot respective assignments points. one plot made, nrow ncol can used specify number rows columns plot grid, respectively.","code":""},{"path":"/reference/PlotSimulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Simulation — PlotSimulation","text":"","code":"# create a SpatSimObj sim_object <- CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10) sim_object = GenerateSpatialPattern(sim_object) sim_object = GenerateTissue(sim_object, density_heatmap = TRUE, step_size = 1, cores = 1) #> Computing density heatmap #> Computing tissue probability # plot a heatmap of tissue 1 PlotSimulation(sim_object, which = 1, what = \"tissue heatmap\")"},{"path":"/reference/SummariseSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Spatial — SummariseSpatial","title":"Summarise Spatial — SummariseSpatial","text":"Summarise Spatial","code":""},{"path":"/reference/SummariseSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Spatial — SummariseSpatial","text":"","code":"SummariseSpatial(spatial_list, markers)"},{"path":"/reference/SummariseSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Spatial — SummariseSpatial","text":"spatial_list list spatial data frames markers column names markers names columns, probably cell types, contain 1s 0s representing positive/negative assignments","code":""},{"path":"/reference/SummariseSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Spatial — SummariseSpatial","text":"data frome summary counts proportions markers spatial data frame","code":""},{"path":"/reference/UpdateSimulationWindow.html","id":null,"dir":"Reference","previous_headings":"","what":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","title":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","text":"function updates simulation window SpatSimObj replacing existing window new one.","code":""},{"path":"/reference/UpdateSimulationWindow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","text":"","code":"UpdateSimulationWindow(sim_object, window = NULL)"},{"path":"/reference/UpdateSimulationWindow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","text":"sim_object SpatSimObj object window new owin object representing updated simulation window","code":""},{"path":"/reference/UpdateSimulationWindow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","text":"updated SpatSimObj object","code":""},{"path":"/reference/UpdateSimulationWindow.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","text":"UpdateSimulationWindow() function checks input sim_object class 'SpatSimObj', input window null class 'owin'. checks pass, function updates simulation window input sim_object returns updated SpatSimObj object.","code":""},{"path":[]},{"path":"/reference/UpdateSimulationWindow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update the simulation window in a SpatSimObj — UpdateSimulationWindow","text":"","code":"# Create a simulation object sim_obj <- CreateSimulationObject() #> No `window` specified - defaulting to x (0, 10); y (0, 10)  # Update the simulation window new_window <- spatstat.geom::owin(c(0, 5), c(0, 5)) updated_sim_obj <- UpdateSimulationWindow(sim_obj, window = new_window)"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::[\\%>\\%][magrittr::pipe] details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/plot.SpatSimObj.html","id":null,"dir":"Reference","previous_headings":"","what":"plot function for SpatSimObj — plot.SpatSimObj","title":"plot function for SpatSimObj — plot.SpatSimObj","text":"plot function SpatSimObj","code":""},{"path":"/reference/plot.SpatSimObj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot function for SpatSimObj — plot.SpatSimObj","text":"","code":"# S3 method for class 'SpatSimObj' plot(x, ...)"},{"path":"/reference/plot.SpatSimObj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot function for SpatSimObj — plot.SpatSimObj","text":"x class SpatSimObj ... things pass plot method SpatSimObj including nrow, ncol number rows columns plots, pattern plot, currently works \"Processes\" may updated future","code":""},{"path":"/reference/plot.SpatSimObj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot function for SpatSimObj — plot.SpatSimObj","text":"basic x-y ggplot object","code":""},{"path":"/reference/summary.SpatSimObj.html","id":null,"dir":"Reference","previous_headings":"","what":"summary function for SpatSimObj — summary.SpatSimObj","title":"summary function for SpatSimObj — summary.SpatSimObj","text":"summary function SpatSimObj","code":""},{"path":"/reference/summary.SpatSimObj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary function for SpatSimObj — summary.SpatSimObj","text":"","code":"# S3 method for class 'SpatSimObj' summary(object, ...)"},{"path":"/reference/summary.SpatSimObj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary function for SpatSimObj — summary.SpatSimObj","text":"object class SpatSimObj ... nothing else pass summary object SpatSimObj","code":""},{"path":"/reference/summary.SpatSimObj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summary function for SpatSimObj — summary.SpatSimObj","text":"summary SpatSimObj terminal","code":""},{"path":"/reference/wm.html","id":null,"dir":"Reference","previous_headings":"","what":"Round spatstat window — wm","title":"Round spatstat window — wm","text":"mask turns window spatstat round mimic window similar tissue microarray image scans","code":""},{"path":"/reference/wm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Round spatstat window — wm","text":"","code":"wm"},{"path":"/reference/wm.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Round spatstat window — wm","text":"owin object many slots describing size mask type mask","code":""}]
